{"version":3,"sources":["index.js","interpreter/main.js","interpreter/messages.js","vm.js","evaluate.js","Function.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;ACFA,AJYA,ACHA,ACHA,ACHA;ACFA,AJYA,ACHA,ACHA,ACHA;ACFA,AJYA,ACHA,ACHA,ACHA;AELA,ADGA,AJYA,ACHA,ACHA,ACHA;AELA,ADGA,AJYA,ACHA,ACHA,ACHA;AELA,ADGA,AJYA,ACHA,ACHA,ACHA;AELA,ADGA,AJYA,ACHA,ACHA,ACHA;AELA,ADGA,AJYA,ACHA,ACHA,ACHA;AELA,ADGA,AJYA,ACHA,ACHA,ACHA;AELA,ADGA,AJYA,ACHA,ACHA,ACHA;AELA,ADGA,AJYA,ACHA,ACHA,ACHA;AELA,ADGA,AJYA,ACHA,ACHA,ACHA;AELA,ADGA,AJYA,ACHA,ACHA,ACHA;AELA,ADGA,AJYA,ACHA,ACHA,ACHA;AELA,ALeA,ACHA,ACHA,ACHA;AELA,ALeA,ACHA,ACHA,ACHA;AELA,ALeA,ACHA,ACHA,ACHA;AELA,ALeA,ACHA,ACHA,ACHA;AELA,ALeA,ACHA,ACHA,ACHA;AELA,ALeA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Interpreter\", {\n  enumerable: true,\n  get: function get() {\n    return _main.Interpreter;\n  }\n});\nObject.defineProperty(exports, \"evaluate\", {\n  enumerable: true,\n  get: function get() {\n    return _evaluate.default;\n  }\n});\nObject.defineProperty(exports, \"Function\", {\n  enumerable: true,\n  get: function get() {\n    return _Function.default;\n  }\n});\nexports.vm = exports.default = void 0;\n\nvar _main = require(\"./interpreter/main\");\n\nvar vm = _interopRequireWildcard(require(\"./vm\"));\n\nexports.vm = vm;\n\nvar _evaluate = _interopRequireDefault(require(\"./evaluate\"));\n\nvar _Function = _interopRequireDefault(require(\"./Function\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nvar _default = _evaluate.default;\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Interpreter = void 0;\n\nvar _acorn = require(\"acorn\");\n\nvar _messages = require(\"./messages\");\n\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar version = \"1.4.7\";\n\nfunction defineFunctionName(func, name) {\n  Object.defineProperty(func, \"name\", {\n    value: name,\n    writable: false,\n    enumerable: false,\n    configurable: true\n  });\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar Break = Symbol(\"Break\");\nvar Continue = Symbol(\"Continue\");\nvar DefaultCase = Symbol(\"DefaultCase\");\nvar EmptyStatementReturn = Symbol(\"EmptyStatementReturn\");\nvar WithScopeName = Symbol(\"WithScopeName\");\nvar SuperScopeName = Symbol(\"SuperScopeName\");\nvar RootScopeName = Symbol(\"RootScopeName\");\nvar GlobalScopeName = Symbol(\"GlobalScopeName\");\n\nfunction isFunction(func) {\n  return typeof func === \"function\";\n}\n\nvar InternalInterpreterReflection =\n/*#__PURE__*/\nfunction () {\n  function InternalInterpreterReflection(interpreter) {\n    this.interpreter = interpreter;\n  }\n\n  var _proto = InternalInterpreterReflection.prototype;\n\n  _proto.generator = function generator() {\n    var interpreter = this.interpreter;\n\n    function getCurrentScope() {\n      return this.getCurrentScope();\n    }\n\n    function getGlobalScope() {\n      return this.getGlobalScope();\n    }\n\n    function getCurrentContext() {\n      return this.getCurrentContext();\n    }\n\n    return {\n      getOptions: interpreter.getOptions.bind(interpreter),\n      getCurrentScope: getCurrentScope.bind(interpreter),\n      getGlobalScope: getGlobalScope.bind(interpreter),\n      getCurrentContext: getCurrentContext.bind(interpreter),\n      getExecStartTime: interpreter.getExecStartTime.bind(interpreter)\n    };\n  };\n\n  return InternalInterpreterReflection;\n}();\n\nfunction internalEval(reflection, code, useGlobalScope) {\n  if (useGlobalScope === void 0) {\n    useGlobalScope = true;\n  }\n\n  if (!(reflection instanceof InternalInterpreterReflection)) {\n    throw new Error(\"Illegal call\");\n  }\n\n  if (typeof code !== \"string\") return code;\n  if (!code) return void 0;\n  var instance = reflection.generator();\n  var opts = instance.getOptions();\n  var options = {\n    timeout: opts.timeout,\n    _initEnv: function _initEnv() {\n      // set caller context\n      if (!useGlobalScope) {\n        this.setCurrentContext(instance.getCurrentContext());\n      } // share timeout\n\n\n      this.execStartTime = instance.getExecStartTime();\n      this.execEndTime = this.execStartTime;\n    }\n  };\n  var currentScope = useGlobalScope ? instance.getGlobalScope() : instance.getCurrentScope();\n  var interpreter = new Interpreter(currentScope, options);\n  return interpreter.evaluate(code);\n}\n\nObject.defineProperty(internalEval, \"__IS_EVAL_FUNC\", {\n  value: true,\n  writable: false,\n  enumerable: false,\n  configurable: false\n});\n\nfunction internalFunction(reflection) {\n  if (!(reflection instanceof InternalInterpreterReflection)) {\n    throw new Error(\"Illegal call\");\n  }\n\n  var instance = reflection.generator();\n\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n\n  var code = params.pop();\n  var interpreter = new Interpreter(instance.getGlobalScope(), instance.getOptions());\n  var wrapCode = \"\\n\\t\\t    (function anonymous(\" + params.join(\",\") + \"){\\n\\t\\t        \" + code + \"\\n\\t\\t    });\\n\\t\\t    \";\n  return interpreter.evaluate(wrapCode);\n}\n\nObject.defineProperty(internalFunction, \"__IS_FUNCTION_FUNC\", {\n  value: true,\n  writable: false,\n  enumerable: false,\n  configurable: false\n});\n\nvar Return = function Return(value) {\n  this.value = value;\n};\n\nvar BreakLabel = function BreakLabel(value) {\n  this.value = value;\n};\n\nvar ContinueLabel = function ContinueLabel(value) {\n  this.value = value;\n};\n/**\r\n * scope chain\r\n *\r\n * superScope\r\n *     ↓\r\n * rootScope\r\n *     ↓\r\n * globalScope\r\n *     ↓\r\n * functionScope\r\n *\r\n */\n\n\nvar Scope = function Scope(data, parent, name) {\n  if (parent === void 0) {\n    parent = null;\n  }\n\n  this.name = name;\n  this.parent = parent;\n  this.data = data;\n  this.labelStack = [];\n};\n\nfunction noop() {}\n\nfunction createScope(parent, name) {\n  if (parent === void 0) {\n    parent = null;\n  }\n\n  return new Scope(Object.create(null), parent, name);\n}\n\nfunction createRootContext(data) {\n  return Object.create(data);\n}\n\nvar BuildInObjects = {\n  NaN: NaN,\n  Infinity: Infinity,\n  undefined: undefined,\n  // null,\n  Object: Object,\n  Array: Array,\n  String: String,\n  Boolean: Boolean,\n  Number: Number,\n  Date: Date,\n  RegExp: RegExp,\n  Error: Error,\n  URIError: URIError,\n  TypeError: TypeError,\n  RangeError: RangeError,\n  SyntaxError: SyntaxError,\n  ReferenceError: ReferenceError,\n  Math: Math,\n  parseInt: parseInt,\n  parseFloat: parseFloat,\n  isNaN: isNaN,\n  isFinite: isFinite,\n  decodeURI: decodeURI,\n  decodeURIComponent: decodeURIComponent,\n  encodeURI: encodeURI,\n  encodeURIComponent: encodeURIComponent,\n  escape: escape,\n  unescape: unescape,\n  eval: internalEval,\n  Function: internalFunction\n}; // ES5 Object\n\nif (typeof JSON !== \"undefined\") {\n  BuildInObjects.JSON = JSON;\n} //ES6 Object\n\n\nif (typeof Promise !== \"undefined\") {\n  BuildInObjects.Promise = Promise;\n}\n\nif (typeof Set !== \"undefined\") {\n  BuildInObjects.Set = Set;\n}\n\nif (typeof Map !== \"undefined\") {\n  BuildInObjects.Map = Map;\n}\n\nif (typeof Symbol !== \"undefined\") {\n  BuildInObjects.Symbol = Symbol;\n}\n\nif (typeof Proxy !== \"undefined\") {\n  BuildInObjects.Proxy = Proxy;\n}\n\nif (typeof WeakMap !== \"undefined\") {\n  BuildInObjects.WeakMap = WeakMap;\n}\n\nif (typeof WeakSet !== \"undefined\") {\n  BuildInObjects.WeakSet = WeakSet;\n}\n\nif (typeof Reflect !== \"undefined\") {\n  BuildInObjects.Reflect = Reflect;\n}\n\nvar Interpreter =\n/*#__PURE__*/\nfunction () {\n  function Interpreter(context, options) {\n    if (context === void 0) {\n      context = Interpreter.global;\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.sourceList = [];\n    this.collectDeclVars = Object.create(null);\n    this.collectDeclFuncs = Object.create(null);\n    this.isVarDeclMode = false;\n    this.lastExecNode = null;\n    this.isRunning = false;\n    this.options = {\n      ecmaVersion: options.ecmaVersion || Interpreter.ecmaVersion,\n      timeout: options.timeout || 0,\n      rootContext: options.rootContext,\n      globalContextInFunction: options.globalContextInFunction === undefined ? Interpreter.globalContextInFunction : options.globalContextInFunction,\n      _initEnv: options._initEnv\n    };\n    this.context = context || Object.create(null);\n    this.callStack = [];\n    this.initEnvironment(this.context);\n  }\n\n  var _proto2 = Interpreter.prototype;\n\n  _proto2.initEnvironment = function initEnvironment(ctx) {\n    var scope; //init global scope\n\n    if (ctx instanceof Scope) {\n      scope = ctx;\n    } else {\n      var rootScope = null;\n      var superScope = this.createSuperScope(ctx);\n\n      if (this.options.rootContext) {\n        rootScope = new Scope(createRootContext(this.options.rootContext), superScope, RootScopeName);\n      }\n\n      scope = new Scope(ctx, rootScope || superScope, GlobalScopeName);\n    }\n\n    this.globalScope = scope;\n    this.currentScope = this.globalScope; //init global context to this\n\n    this.globalContext = scope.data;\n    this.currentContext = scope.data; // collect var/function declare\n\n    this.collectDeclVars = Object.create(null);\n    this.collectDeclFuncs = Object.create(null);\n    this.execStartTime = Date.now();\n    this.execEndTime = this.execStartTime;\n    var _initEnv = this.options._initEnv;\n\n    if (_initEnv) {\n      _initEnv.call(this);\n    }\n  };\n\n  _proto2.getExecStartTime = function getExecStartTime() {\n    return this.execStartTime;\n  };\n\n  _proto2.getExecutionTime = function getExecutionTime() {\n    return this.execEndTime - this.execStartTime;\n  };\n\n  _proto2.setExecTimeout = function setExecTimeout(timeout) {\n    if (timeout === void 0) {\n      timeout = 0;\n    }\n\n    this.options.timeout = timeout;\n  };\n\n  _proto2.getOptions = function getOptions() {\n    return this.options;\n  };\n\n  _proto2.getGlobalScope = function getGlobalScope() {\n    return this.globalScope;\n  };\n\n  _proto2.getCurrentScope = function getCurrentScope() {\n    return this.currentScope;\n  };\n\n  _proto2.getCurrentContext = function getCurrentContext() {\n    return this.currentContext;\n  };\n\n  _proto2.isInterruptThrow = function isInterruptThrow(err) {\n    return err instanceof _messages.InterruptThrowError || err instanceof _messages.InterruptThrowReferenceError || err instanceof _messages.InterruptThrowSyntaxError;\n  };\n\n  _proto2.createSuperScope = function createSuperScope(ctx) {\n    var data = Object.assign({}, BuildInObjects);\n    var buildInObjectKeys = Object.keys(data);\n    buildInObjectKeys.forEach(function (key) {\n      if (key in ctx) {\n        delete data[key];\n      }\n    });\n    return new Scope(data, null, SuperScopeName);\n  };\n\n  _proto2.setCurrentContext = function setCurrentContext(ctx) {\n    this.currentContext = ctx;\n  };\n\n  _proto2.setCurrentScope = function setCurrentScope(scope) {\n    this.currentScope = scope;\n  };\n\n  _proto2.evaluate = function evaluate(code) {\n    if (code === void 0) {\n      code = \"\";\n    }\n\n    var node;\n    if (!code) return;\n    node = (0, _acorn.parse)(code, {\n      ranges: true,\n      locations: true,\n      ecmaVersion: this.options.ecmaVersion || Interpreter.ecmaVersion\n    });\n    return this.evaluateNode(node, code);\n  };\n\n  _proto2.appendCode = function appendCode(code) {\n    return this.evaluate(code);\n  };\n\n  _proto2.evaluateNode = function evaluateNode(node, source) {\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"\";\n    }\n\n    this.value = undefined;\n    this.source = source;\n    this.sourceList.push(source);\n    this.isRunning = true; //reset timeout\n\n    this.execStartTime = Date.now();\n    this.execEndTime = this.execStartTime; // reset\n\n    this.collectDeclVars = Object.create(null);\n    this.collectDeclFuncs = Object.create(null);\n    var currentScope = this.getCurrentScope();\n    var currentContext = this.getCurrentContext();\n    var labelStack = currentScope.labelStack.concat([]);\n    var callStack = this.callStack.concat([]);\n\n    var reset = function reset() {\n      _this.setCurrentScope(currentScope); //reset scope\n\n\n      _this.setCurrentContext(currentContext); //reset context\n\n\n      currentScope.labelStack = labelStack; //reset label stack\n\n      _this.callStack = callStack; //reset call stack\n    }; // start run\n\n\n    try {\n      var bodyClosure = this.createClosure(node); // add declares to data\n\n      this.addDeclarationsToScope(this.collectDeclVars, this.collectDeclFuncs, this.getCurrentScope());\n      bodyClosure();\n    } catch (e) {\n      throw e;\n    } finally {\n      reset();\n      this.execEndTime = Date.now();\n    }\n\n    this.isRunning = false;\n    return this.getValue();\n  };\n\n  _proto2.createErrorMessage = function createErrorMessage(msg, value, node) {\n    var message = msg[1].replace(\"%0\", String(value));\n\n    if (node !== null) {\n      message += this.getNodePosition(node || this.lastExecNode);\n    }\n\n    return message;\n  };\n\n  _proto2.createError = function createError(message, error) {\n    return new error(message);\n  };\n\n  _proto2.createThrowError = function createThrowError(message, error) {\n    return this.createError(message, error);\n  };\n\n  _proto2.createInternalThrowError = function createInternalThrowError(msg, value, node) {\n    return this.createError(this.createErrorMessage(msg, value, node), msg[2]);\n  };\n\n  _proto2.checkTimeout = function checkTimeout() {\n    if (!this.isRunning) return false;\n    var timeout = this.options.timeout || 0;\n    var now = Date.now();\n\n    if (now - this.execStartTime > timeout) {\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto2.getNodePosition = function getNodePosition(node) {\n    if (node) {\n      var errorCode = \"\"; //this.source.slice(node.start, node.end);\n\n      return node.loc ? \" [\" + node.loc.start.line + \":\" + node.loc.start.column + \"]\" + errorCode : \"\";\n    }\n\n    return \"\";\n  };\n\n  _proto2.createClosure = function createClosure(node) {\n    var _this2 = this;\n\n    var closure;\n\n    switch (node.type) {\n      case \"BinaryExpression\":\n        closure = this.binaryExpressionHandler(node);\n        break;\n\n      case \"LogicalExpression\":\n        closure = this.logicalExpressionHandler(node);\n        break;\n\n      case \"UnaryExpression\":\n        closure = this.unaryExpressionHandler(node);\n        break;\n\n      case \"UpdateExpression\":\n        closure = this.updateExpressionHandler(node);\n        break;\n\n      case \"ObjectExpression\":\n        closure = this.objectExpressionHandler(node);\n        break;\n\n      case \"ArrayExpression\":\n        closure = this.arrayExpressionHandler(node);\n        break;\n\n      case \"CallExpression\":\n        closure = this.callExpressionHandler(node);\n        break;\n\n      case \"NewExpression\":\n        closure = this.newExpressionHandler(node);\n        break;\n\n      case \"MemberExpression\":\n        closure = this.memberExpressionHandler(node);\n        break;\n\n      case \"ThisExpression\":\n        closure = this.thisExpressionHandler(node);\n        break;\n\n      case \"SequenceExpression\":\n        closure = this.sequenceExpressionHandler(node);\n        break;\n\n      case \"Literal\":\n        closure = this.literalHandler(node);\n        break;\n\n      case \"Identifier\":\n        closure = this.identifierHandler(node);\n        break;\n\n      case \"AssignmentExpression\":\n        closure = this.assignmentExpressionHandler(node);\n        break;\n\n      case \"FunctionDeclaration\":\n        closure = this.functionDeclarationHandler(node);\n        break;\n\n      case \"VariableDeclaration\":\n        closure = this.variableDeclarationHandler(node);\n        break;\n\n      case \"BlockStatement\":\n      case \"Program\":\n        closure = this.programHandler(node);\n        break;\n\n      case \"ExpressionStatement\":\n        closure = this.expressionStatementHandler(node);\n        break;\n\n      case \"EmptyStatement\":\n        closure = this.emptyStatementHandler(node);\n        break;\n\n      case \"ReturnStatement\":\n        closure = this.returnStatementHandler(node);\n        break;\n\n      case \"FunctionExpression\":\n        closure = this.functionExpressionHandler(node);\n        break;\n\n      case \"IfStatement\":\n        closure = this.ifStatementHandler(node);\n        break;\n\n      case \"ConditionalExpression\":\n        closure = this.conditionalExpressionHandler(node);\n        break;\n\n      case \"ForStatement\":\n        closure = this.forStatementHandler(node);\n        break;\n\n      case \"WhileStatement\":\n        closure = this.whileStatementHandler(node);\n        break;\n\n      case \"DoWhileStatement\":\n        closure = this.doWhileStatementHandler(node);\n        break;\n\n      case \"ForInStatement\":\n        closure = this.forInStatementHandler(node);\n        break;\n\n      case \"WithStatement\":\n        closure = this.withStatementHandler(node);\n        break;\n\n      case \"ThrowStatement\":\n        closure = this.throwStatementHandler(node);\n        break;\n\n      case \"TryStatement\":\n        closure = this.tryStatementHandler(node);\n        break;\n\n      case \"ContinueStatement\":\n        closure = this.continueStatementHandler(node);\n        break;\n\n      case \"BreakStatement\":\n        closure = this.breakStatementHandler(node);\n        break;\n\n      case \"SwitchStatement\":\n        closure = this.switchStatementHandler(node);\n        break;\n\n      case \"LabeledStatement\":\n        closure = this.labeledStatementHandler(node);\n        break;\n\n      case \"DebuggerStatement\":\n        closure = this.debuggerStatementHandler(node);\n        break;\n\n      default:\n        throw this.createInternalThrowError(_messages.Messages.NodeTypeSyntaxError, node.type, node);\n    }\n\n    return function () {\n      var timeout = _this2.options.timeout;\n\n      if (timeout && timeout > 0 && _this2.checkTimeout()) {\n        throw _this2.createInternalThrowError(_messages.Messages.ExecutionTimeOutError, timeout, null);\n      }\n\n      _this2.lastExecNode = node;\n      return closure.apply(void 0, arguments);\n    };\n  } // a==b a/b\n  ;\n\n  _proto2.binaryExpressionHandler = function binaryExpressionHandler(node) {\n    var _this3 = this;\n\n    var leftExpression = this.createClosure(node.left);\n    var rightExpression = this.createClosure(node.right);\n    return function () {\n      var leftValue = leftExpression();\n      var rightValue = rightExpression();\n\n      switch (node.operator) {\n        case \"==\":\n          return leftValue == rightValue;\n\n        case \"!=\":\n          return leftValue != rightValue;\n\n        case \"===\":\n          return leftValue === rightValue;\n\n        case \"!==\":\n          return leftValue !== rightValue;\n\n        case \"<\":\n          return leftValue < rightValue;\n\n        case \"<=\":\n          return leftValue <= rightValue;\n\n        case \">\":\n          return leftValue > rightValue;\n\n        case \">=\":\n          return leftValue >= rightValue;\n\n        case \"<<\":\n          return leftValue << rightValue;\n\n        case \">>\":\n          return leftValue >> rightValue;\n\n        case \">>>\":\n          return leftValue >>> rightValue;\n\n        case \"+\":\n          return leftValue + rightValue;\n\n        case \"-\":\n          return leftValue - rightValue;\n\n        case \"*\":\n          return leftValue * rightValue;\n\n        case \"**\":\n          return Math.pow(leftValue, rightValue);\n\n        case \"/\":\n          return leftValue / rightValue;\n\n        case \"%\":\n          return leftValue % rightValue;\n\n        case \"|\":\n          return leftValue | rightValue;\n\n        case \"^\":\n          return leftValue ^ rightValue;\n\n        case \"&\":\n          return leftValue & rightValue;\n\n        case \"in\":\n          return leftValue in rightValue;\n\n        case \"instanceof\":\n          return leftValue instanceof rightValue;\n\n        default:\n          throw _this3.createInternalThrowError(_messages.Messages.BinaryOperatorSyntaxError, node.operator, node);\n      }\n    };\n  } // a && b\n  ;\n\n  _proto2.logicalExpressionHandler = function logicalExpressionHandler(node) {\n    var _this4 = this;\n\n    var leftExpression = this.createClosure(node.left);\n    var rightExpression = this.createClosure(node.right);\n    return function () {\n      switch (node.operator) {\n        case \"||\":\n          return leftExpression() || rightExpression();\n\n        case \"&&\":\n          return leftExpression() && rightExpression();\n\n        default:\n          throw _this4.createInternalThrowError(_messages.Messages.LogicalOperatorSyntaxError, node.operator, node);\n      }\n    };\n  } // protected isRootScope(node: ESTree.Expression | ESTree.Pattern): boolean {\n  // \tif (node.type === \"Identifier\") {\n  // \t\tconst scope = this.getScopeFromName(node.name, this.getCurrentScope());\n  // \t\treturn scope.name === \"rootScope\";\n  // \t}\n  // \treturn false;\n  // }\n  // typeof a !a()\n  ;\n\n  _proto2.unaryExpressionHandler = function unaryExpressionHandler(node) {\n    var _this5 = this;\n\n    switch (node.operator) {\n      case \"delete\":\n        var objectGetter = this.createObjectGetter(node.argument);\n        var nameGetter = this.createNameGetter(node.argument);\n        return function () {\n          // not allowed to delete root scope property\n          // rootContext has move to prototype chai, so no judgment required\n          // if (this.isRootScope(node.argument)) {\n          // \treturn false;\n          // }\n          var obj = objectGetter();\n          var name = nameGetter();\n          return delete obj[name];\n        };\n\n      default:\n        var expression; // for typeof undefined var\n        // typeof adf9ad\n\n        if (node.operator === \"typeof\" && node.argument.type === \"Identifier\") {\n          var _objectGetter = this.createObjectGetter(node.argument);\n\n          var _nameGetter = this.createNameGetter(node.argument);\n\n          expression = function expression() {\n            return _objectGetter()[_nameGetter()];\n          };\n        } else {\n          expression = this.createClosure(node.argument);\n        }\n\n        return function () {\n          var value = expression();\n\n          switch (node.operator) {\n            case \"-\":\n              return -value;\n\n            case \"+\":\n              return +value;\n\n            case \"!\":\n              return !value;\n\n            case \"~\":\n              return ~value;\n\n            case \"void\":\n              return void value;\n\n            case \"typeof\":\n              return typeof value;\n\n            default:\n              throw _this5.createInternalThrowError(_messages.Messages.UnaryOperatorSyntaxError, node.operator, node);\n          }\n        };\n    }\n  } // ++a --a\n  ;\n\n  _proto2.updateExpressionHandler = function updateExpressionHandler(node) {\n    var _this6 = this;\n\n    var objectGetter = this.createObjectGetter(node.argument);\n    var nameGetter = this.createNameGetter(node.argument);\n    return function () {\n      var obj = objectGetter();\n      var name = nameGetter();\n\n      _this6.assertVariable(obj, name, node);\n\n      switch (node.operator) {\n        case \"++\":\n          return node.prefix ? ++obj[name] : obj[name]++;\n\n        case \"--\":\n          return node.prefix ? --obj[name] : obj[name]--;\n\n        default:\n          throw _this6.createInternalThrowError(_messages.Messages.UpdateOperatorSyntaxError, node.operator, node);\n      }\n    };\n  } // var o = {a: 1, b: 's', get name(){}, set name(){}  ...}\n  ;\n\n  _proto2.objectExpressionHandler = function objectExpressionHandler(node) {\n    var _this7 = this;\n\n    var items = [];\n\n    function getKey(keyNode) {\n      if (keyNode.type === \"Identifier\") {\n        // var o = {a:1}\n        return keyNode.name;\n      } else if (keyNode.type === \"Literal\") {\n        // var o = {\"a\":1}\n        return keyNode.value;\n      } else {\n        return this.throwError(_messages.Messages.ObjectStructureSyntaxError, keyNode.type, keyNode);\n      }\n    } // collect value, getter, and/or setter.\n\n\n    var properties = Object.create(null);\n    node.properties.forEach(function (property) {\n      var kind = property.kind;\n      var key = getKey(property.key);\n\n      if (!properties[key] || kind === \"init\") {\n        properties[key] = {};\n      }\n\n      properties[key][kind] = _this7.createClosure(property.value);\n      items.push({\n        key: key,\n        property: property\n      });\n    });\n    return function () {\n      var result = {};\n      var len = items.length;\n\n      for (var i = 0; i < len; i++) {\n        var item = items[i];\n        var key = item.key;\n        var kinds = properties[key];\n        var value = kinds.init ? kinds.init() : undefined;\n        var getter = kinds.get ? kinds.get() : function () {};\n        var setter = kinds.set ? kinds.set() : function (a) {};\n\n        if (\"set\" in kinds || \"get\" in kinds) {\n          var descriptor = {\n            configurable: true,\n            enumerable: true,\n            get: getter,\n            set: setter\n          };\n          Object.defineProperty(result, key, descriptor);\n        } else {\n          var property = item.property;\n          var kind = property.kind; // set function.name\n          // var d = { test(){} }\n          // var d = { test: function(){} }\n\n          if (property.key.type === \"Identifier\" && property.value.type === \"FunctionExpression\" && kind === \"init\" && !property.value.id) {\n            defineFunctionName(value, property.key.name);\n          }\n\n          result[key] = value;\n        }\n      }\n\n      return result;\n    };\n  } // [1,2,3]\n  ;\n\n  _proto2.arrayExpressionHandler = function arrayExpressionHandler(node) {\n    var _this8 = this;\n\n    //fix: [,,,1,2]\n    var items = node.elements.map(function (element) {\n      return element ? _this8.createClosure(element) : element;\n    });\n    return function () {\n      var len = items.length;\n      var result = Array(len);\n\n      for (var i = 0; i < len; i++) {\n        var item = items[i];\n\n        if (item) {\n          result[i] = item();\n        }\n      }\n\n      return result;\n    };\n  };\n\n  _proto2.safeObjectGet = function safeObjectGet(obj, key, node) {\n    return obj[key];\n  };\n\n  _proto2.createCallFunctionGetter = function createCallFunctionGetter(node) {\n    var _this9 = this;\n\n    switch (node.type) {\n      case \"MemberExpression\":\n        var objectGetter = this.createClosure(node.object);\n        var keyGetter = this.createMemberKeyGetter(node);\n        var source = this.source;\n        return function () {\n          var obj = objectGetter();\n          var key = keyGetter();\n\n          var func = _this9.safeObjectGet(obj, key, node);\n\n          if (!func || !isFunction(func)) {\n            var name = source.slice(node.start, node.end);\n            throw _this9.createInternalThrowError(_messages.Messages.FunctionUndefinedReferenceError, name, node);\n          } // obj.eval = eval\n          // obj.eval(...)\n\n\n          if (func.__IS_EVAL_FUNC) {\n            return function (code) {\n              return func(new InternalInterpreterReflection(_this9), code, true);\n            };\n          } // obj.func = Function\n          // obj.func(...)\n\n\n          if (func.__IS_FUNCTION_FUNC) {\n            return function () {\n              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                args[_key2] = arguments[_key2];\n              }\n\n              return func.apply(void 0, [new InternalInterpreterReflection(_this9)].concat(args));\n            };\n          } // method call\n          // eg：obj.say(...)\n          // eg: obj.say.call(...)\n          // eg: obj.say.apply(...)\n          // ======================\n          // obj.func(...)\n          // func = func.bind(obj)\n          // tips:\n          // func(...) -> func.bind(obj)(...)\n          // func.call(...) -> obj.func.call.bind(obj.func)(...)\n          // func.apply(...) -> obj.func.apply.bind(obj.func)(...)\n          // ...others\n\n\n          return func.bind(obj);\n        };\n\n      default:\n        // test() or (0,test)() or a[1]() ...\n        var closure = this.createClosure(node);\n        return function () {\n          var name = \"\";\n\n          if (node.type === \"Identifier\") {\n            name = node.name;\n          } // const name: string = (<ESTree.Identifier>node).name;\n\n\n          var func = closure();\n\n          if (!func || !isFunction(func)) {\n            throw _this9.createInternalThrowError(_messages.Messages.FunctionUndefinedReferenceError, name, node);\n          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval\n          // var eval = eval;\n          // function test(){\n          //    eval(...); //note: use local scope in eval5，but in Browser is use global scope\n          // }\n\n\n          if (node.type === \"Identifier\" && func.__IS_EVAL_FUNC && name === \"eval\") {\n            return function (code) {\n              var scope = _this9.getScopeFromName(name, _this9.getCurrentScope());\n\n              var useGlobalScope = scope.name === SuperScopeName || // !scope.parent || // super scope\n              scope.name === GlobalScopeName || // this.globalScope === scope ||\n              scope.name === RootScopeName; // use local scope if calling eval in super scope\n\n              return func(new InternalInterpreterReflection(_this9), code, !useGlobalScope);\n            };\n          } // use global scope\n          // var g_eval = eval;\n          // g_eval(\"a+1\");\n          //(0,eval)(...) ...eval alias\n\n\n          if (func.__IS_EVAL_FUNC) {\n            return function (code) {\n              return func(new InternalInterpreterReflection(_this9), code, true);\n            };\n          } // Function('a', 'b', 'return a+b')\n\n\n          if (func.__IS_FUNCTION_FUNC) {\n            return function () {\n              for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n                args[_key3] = arguments[_key3];\n              }\n\n              return func.apply(void 0, [new InternalInterpreterReflection(_this9)].concat(args));\n            };\n          }\n\n          var ctx = _this9.options.globalContextInFunction; // with(obj) {\n          //     test() // test.call(obj, ...)\n          // }\n\n          if (node.type === \"Identifier\") {\n            var scope = _this9.getIdentifierScope(node);\n\n            if (scope.name === WithScopeName) {\n              ctx = scope.data;\n            }\n          } // function call\n          // this = undefined\n          // tips:\n          // test(...) === test.call(undefined, ...)\n          // fix: alert.call({}, ...) Illegal invocation\n\n\n          return func.bind(ctx);\n        };\n    }\n  } // func()\n  ;\n\n  _proto2.callExpressionHandler = function callExpressionHandler(node) {\n    var _this10 = this;\n\n    var funcGetter = this.createCallFunctionGetter(node.callee);\n    var argsGetter = node.arguments.map(function (arg) {\n      return _this10.createClosure(arg);\n    });\n    return function () {\n      return funcGetter().apply(void 0, argsGetter.map(function (arg) {\n        return arg();\n      }));\n    };\n  } // var f = function() {...}\n  ;\n\n  _proto2.functionExpressionHandler = function functionExpressionHandler(node) {\n    var _this11 = this;\n\n    var self = this;\n    var source = this.source;\n    var oldDeclVars = this.collectDeclVars;\n    var oldDeclFuncs = this.collectDeclFuncs;\n    this.collectDeclVars = Object.create(null);\n    this.collectDeclFuncs = Object.create(null);\n    var name = node.id ? node.id.name : \"\";\n    /**anonymous*/\n\n    var paramLength = node.params.length;\n    var paramsGetter = node.params.map(function (param) {\n      return _this11.createParamNameGetter(param);\n    }); // set scope\n\n    var bodyClosure = this.createClosure(node.body);\n    var declVars = this.collectDeclVars;\n    var declFuncs = this.collectDeclFuncs;\n    this.collectDeclVars = oldDeclVars;\n    this.collectDeclFuncs = oldDeclFuncs;\n    return function () {\n      // bind current scope\n      var runtimeScope = self.getCurrentScope();\n\n      var func = function func() {\n        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n          args[_key4] = arguments[_key4];\n        }\n\n        self.callStack.push(\"\" + name);\n        var prevScope = self.getCurrentScope();\n        var currentScope = createScope(runtimeScope, \"FunctionScope(\" + name + \")\");\n        self.setCurrentScope(currentScope);\n        self.addDeclarationsToScope(declVars, declFuncs, currentScope); // var t = function(){ typeof t } // function\n        // t = function(){ typeof t } // function\n        // z = function tx(){ typeof tx } // function\n        // but\n        // d = { say: function(){ typeof say } } // undefined\n\n        if (name) {\n          currentScope.data[name] = func;\n        } // init arguments var\n\n\n        currentScope.data[\"arguments\"] = arguments;\n        paramsGetter.forEach(function (getter, i) {\n          currentScope.data[getter()] = args[i];\n        }); // init this\n\n        var prevContext = self.getCurrentContext(); //for ThisExpression\n\n        self.setCurrentContext(this);\n        var result = bodyClosure(); //reset\n\n        self.setCurrentContext(prevContext);\n        self.setCurrentScope(prevScope);\n        self.callStack.pop();\n\n        if (result instanceof Return) {\n          return result.value;\n        }\n      };\n\n      defineFunctionName(func, name);\n      Object.defineProperty(func, \"length\", {\n        value: paramLength,\n        writable: false,\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(func, \"toString\", {\n        value: function value() {\n          return source.slice(node.start, node.end);\n        },\n        writable: true,\n        configurable: true,\n        enumerable: false\n      });\n      Object.defineProperty(func, \"valueOf\", {\n        value: function value() {\n          return source.slice(node.start, node.end);\n        },\n        writable: true,\n        configurable: true,\n        enumerable: false\n      });\n      return func;\n    };\n  } // new Ctrl()\n  ;\n\n  _proto2.newExpressionHandler = function newExpressionHandler(node) {\n    var _this12 = this;\n\n    var source = this.source;\n    var expression = this.createClosure(node.callee);\n    var args = node.arguments.map(function (arg) {\n      return _this12.createClosure(arg);\n    });\n    return function () {\n      var construct = expression();\n\n      if (!isFunction(construct) || construct.__IS_EVAL_FUNC) {\n        var callee = node.callee;\n        var name = source.slice(callee.start, callee.end);\n        throw _this12.createInternalThrowError(_messages.Messages.IsNotConstructor, name, node);\n      } // new Function(...)\n\n\n      if (construct.__IS_FUNCTION_FUNC) {\n        return construct.apply(void 0, [new InternalInterpreterReflection(_this12)].concat(args.map(function (arg) {\n          return arg();\n        })));\n      }\n\n      return _construct(construct, args.map(function (arg) {\n        return arg();\n      }));\n    };\n  } // a.b a['b']\n  ;\n\n  _proto2.memberExpressionHandler = function memberExpressionHandler(node) {\n    var objectGetter = this.createClosure(node.object);\n    var keyGetter = this.createMemberKeyGetter(node);\n    return function () {\n      var obj = objectGetter();\n      var key = keyGetter();\n      return obj[key];\n    };\n  } //this\n  ;\n\n  _proto2.thisExpressionHandler = function thisExpressionHandler(node) {\n    var _this13 = this;\n\n    return function () {\n      return _this13.getCurrentContext();\n    };\n  } // var1,var2,...\n  ;\n\n  _proto2.sequenceExpressionHandler = function sequenceExpressionHandler(node) {\n    var _this14 = this;\n\n    var expressions = node.expressions.map(function (item) {\n      return _this14.createClosure(item);\n    });\n    return function () {\n      var result;\n      var len = expressions.length;\n\n      for (var i = 0; i < len; i++) {\n        var expression = expressions[i];\n        result = expression();\n      }\n\n      return result;\n    };\n  } // 1 'name'\n  ;\n\n  _proto2.literalHandler = function literalHandler(node) {\n    return function () {\n      if (node.regex) {\n        return new RegExp(node.regex.pattern, node.regex.flags);\n      }\n\n      return node.value;\n    };\n  } // var1 ...\n  ;\n\n  _proto2.identifierHandler = function identifierHandler(node) {\n    var _this15 = this;\n\n    return function () {\n      var currentScope = _this15.getCurrentScope();\n\n      var data = _this15.getScopeDataFromName(node.name, currentScope);\n\n      _this15.assertVariable(data, node.name, node);\n\n      return data[node.name];\n    };\n  };\n\n  _proto2.getIdentifierScope = function getIdentifierScope(node) {\n    var currentScope = this.getCurrentScope();\n    var scope = this.getScopeFromName(node.name, currentScope);\n    return scope;\n  } // a=1 a+=2\n  ;\n\n  _proto2.assignmentExpressionHandler = function assignmentExpressionHandler(node) {\n    var _this16 = this;\n\n    // var s = function(){}\n    // s.name === s\n    if (node.left.type === \"Identifier\" && node.right.type === \"FunctionExpression\" && !node.right.id) {\n      node.right.id = {\n        type: \"Identifier\",\n        name: node.left.name\n      };\n    }\n\n    var dataGetter = this.createObjectGetter(node.left);\n    var nameGetter = this.createNameGetter(node.left);\n    var rightValueGetter = this.createClosure(node.right);\n    return function () {\n      var data = dataGetter();\n      var name = nameGetter();\n      var rightValue = rightValueGetter();\n\n      if (node.operator !== \"=\") {\n        // if a is undefined\n        // a += 1\n        _this16.assertVariable(data, name, node);\n      }\n\n      switch (node.operator) {\n        case \"=\":\n          return data[name] = rightValue;\n\n        case \"+=\":\n          return data[name] += rightValue;\n\n        case \"-=\":\n          return data[name] -= rightValue;\n\n        case \"*=\":\n          return data[name] *= rightValue;\n\n        case \"**=\":\n          return data[name] = Math.pow(data[name], rightValue);\n\n        case \"/=\":\n          return data[name] /= rightValue;\n\n        case \"%=\":\n          return data[name] %= rightValue;\n\n        case \"<<=\":\n          return data[name] <<= rightValue;\n\n        case \">>=\":\n          return data[name] >>= rightValue;\n\n        case \">>>=\":\n          return data[name] >>>= rightValue;\n\n        case \"&=\":\n          return data[name] &= rightValue;\n\n        case \"^=\":\n          return data[name] ^= rightValue;\n\n        case \"|=\":\n          return data[name] |= rightValue;\n\n        default:\n          throw _this16.createInternalThrowError(_messages.Messages.AssignmentExpressionSyntaxError, node.type, node);\n      }\n    };\n  } // function test(){}\n  ;\n\n  _proto2.functionDeclarationHandler = function functionDeclarationHandler(node) {\n    if (node.id) {\n      var functionClosure = this.functionExpressionHandler(node);\n      Object.defineProperty(functionClosure, \"isFunctionDeclareClosure\", {\n        value: true,\n        writable: false,\n        configurable: false,\n        enumerable: false\n      });\n      this.funcDeclaration(node.id.name, functionClosure);\n    }\n\n    return function () {\n      return EmptyStatementReturn;\n    };\n  };\n\n  _proto2.getVariableName = function getVariableName(node) {\n    if (node.type === \"Identifier\") {\n      return node.name;\n    } else {\n      throw this.createInternalThrowError(_messages.Messages.VariableTypeSyntaxError, node.type, node);\n    }\n  } // var i;\n  // var i=1;\n  ;\n\n  _proto2.variableDeclarationHandler = function variableDeclarationHandler(node) {\n    var _this17 = this;\n\n    var assignmentsClosure;\n    var assignments = [];\n\n    for (var i = 0; i < node.declarations.length; i++) {\n      var decl = node.declarations[i];\n      this.varDeclaration(this.getVariableName(decl.id));\n\n      if (decl.init) {\n        assignments.push({\n          type: \"AssignmentExpression\",\n          operator: \"=\",\n          left: decl.id,\n          right: decl.init\n        });\n      }\n    }\n\n    if (assignments.length) {\n      assignmentsClosure = this.createClosure({\n        type: \"BlockStatement\",\n        body: assignments\n      });\n    }\n\n    return function () {\n      if (assignmentsClosure) {\n        var oldValue = _this17.isVarDeclMode;\n        _this17.isVarDeclMode = true;\n        assignmentsClosure();\n        _this17.isVarDeclMode = oldValue;\n      }\n\n      return EmptyStatementReturn;\n    };\n  };\n\n  _proto2.assertVariable = function assertVariable(data, name, node) {\n    if (data === this.globalScope.data && !(name in data)) {\n      throw this.createInternalThrowError(_messages.Messages.VariableUndefinedReferenceError, name, node);\n    }\n  } // {...}\n  ;\n\n  _proto2.programHandler = function programHandler(node) {\n    var _this18 = this;\n\n    // const currentScope = this.getCurrentScope();\n    var stmtClosures = node.body.map(function (stmt) {\n      // if (stmt.type === \"EmptyStatement\") return null;\n      return _this18.createClosure(stmt);\n    });\n    return function () {\n      var result = EmptyStatementReturn;\n\n      for (var i = 0; i < stmtClosures.length; i++) {\n        var stmtClosure = stmtClosures[i]; // save last value\n\n        var ret = _this18.setValue(stmtClosure()); // if (!stmtClosure) continue;\n        // EmptyStatement\n\n\n        if (ret === EmptyStatementReturn) continue;\n        result = ret; // BlockStatement: break label;  continue label; for(){ break ... }\n        // ReturnStatement: return xx;\n\n        if (result instanceof Return || result instanceof BreakLabel || result instanceof ContinueLabel || result === Break || result === Continue) {\n          break;\n        }\n      } // save last value\n\n\n      return result;\n    };\n  } // all expression: a+1 a&&b a() a.b ...\n  ;\n\n  _proto2.expressionStatementHandler = function expressionStatementHandler(node) {\n    return this.createClosure(node.expression);\n  };\n\n  _proto2.emptyStatementHandler = function emptyStatementHandler(node) {\n    return function () {\n      return EmptyStatementReturn;\n    };\n  } // return xx;\n  ;\n\n  _proto2.returnStatementHandler = function returnStatementHandler(node) {\n    var argumentClosure = node.argument ? this.createClosure(node.argument) : noop;\n    return function () {\n      return new Return(argumentClosure());\n    };\n  } // if else\n  ;\n\n  _proto2.ifStatementHandler = function ifStatementHandler(node) {\n    var testClosure = this.createClosure(node.test);\n    var consequentClosure = this.createClosure(node.consequent);\n    var alternateClosure = node.alternate ? this.createClosure(node.alternate) :\n    /*!important*/\n    function () {\n      return EmptyStatementReturn;\n    };\n    return function () {\n      return testClosure() ? consequentClosure() : alternateClosure();\n    };\n  } // test() ? true : false\n  ;\n\n  _proto2.conditionalExpressionHandler = function conditionalExpressionHandler(node) {\n    return this.ifStatementHandler(node);\n  } // for(var i = 0; i < 10; i++) {...}\n  ;\n\n  _proto2.forStatementHandler = function forStatementHandler(node) {\n    var _this19 = this;\n\n    var initClosure = noop;\n    var testClosure = node.test ? this.createClosure(node.test) : function () {\n      return true;\n    };\n    var updateClosure = noop;\n    var bodyClosure = this.createClosure(node.body);\n\n    if (node.type === \"ForStatement\") {\n      initClosure = node.init ? this.createClosure(node.init) : initClosure;\n      updateClosure = node.update ? this.createClosure(node.update) : noop;\n    }\n\n    return function (pNode) {\n      var labelName;\n      var result = EmptyStatementReturn;\n      var shouldInitExec = node.type === \"DoWhileStatement\";\n\n      if (pNode && pNode.type === \"LabeledStatement\") {\n        labelName = pNode.label.name;\n      }\n\n      for (initClosure(); shouldInitExec || testClosure(); updateClosure()) {\n        shouldInitExec = false; // save last value\n\n        var ret = _this19.setValue(bodyClosure()); // notice: never return Break or Continue!\n\n\n        if (ret === EmptyStatementReturn || ret === Continue) continue;\n\n        if (ret === Break) {\n          break;\n        }\n\n        result = ret; // stop continue label\n\n        if (result instanceof ContinueLabel && result.value === labelName) {\n          result = EmptyStatementReturn;\n          continue;\n        }\n\n        if (result instanceof Return || result instanceof BreakLabel || result instanceof ContinueLabel) {\n          break;\n        }\n      }\n\n      return result;\n    };\n  } // while(1) {...}\n  ;\n\n  _proto2.whileStatementHandler = function whileStatementHandler(node) {\n    return this.forStatementHandler(node);\n  };\n\n  _proto2.doWhileStatementHandler = function doWhileStatementHandler(node) {\n    return this.forStatementHandler(node);\n  };\n\n  _proto2.forInStatementHandler = function forInStatementHandler(node) {\n    var _this20 = this;\n\n    // for( k in obj) or for(o.k in obj) ...\n    var left = node.left;\n    var rightClosure = this.createClosure(node.right);\n    var bodyClosure = this.createClosure(node.body); // for(var k in obj) {...}\n\n    if (node.left.type === \"VariableDeclaration\") {\n      // init var k\n      this.createClosure(node.left)(); // reset left\n      // for( k in obj)\n\n      left = node.left.declarations[0].id;\n    }\n\n    return function (pNode) {\n      var labelName;\n      var result = EmptyStatementReturn;\n      var x;\n\n      if (pNode && pNode.type === \"LabeledStatement\") {\n        labelName = pNode.label.name;\n      }\n\n      var data = rightClosure();\n\n      for (x in data) {\n        // assign left to scope\n        // k = x\n        // o.k = x\n        _this20.assignmentExpressionHandler({\n          type: \"AssignmentExpression\",\n          operator: \"=\",\n          left: left,\n          right: {\n            type: \"Literal\",\n            value: x\n          }\n        })(); // save last value\n\n\n        var ret = _this20.setValue(bodyClosure()); // notice: never return Break or Continue!\n\n\n        if (ret === EmptyStatementReturn || ret === Continue) continue;\n\n        if (ret === Break) {\n          break;\n        }\n\n        result = ret; // stop continue label\n\n        if (result instanceof ContinueLabel && result.value === labelName) {\n          result = EmptyStatementReturn;\n          continue;\n        }\n\n        if (result instanceof Return || result instanceof BreakLabel || result instanceof ContinueLabel) {\n          break;\n        }\n      }\n\n      return result;\n    };\n  };\n\n  _proto2.withStatementHandler = function withStatementHandler(node) {\n    var _this21 = this;\n\n    var objectClosure = this.createClosure(node.object);\n    var bodyClosure = this.createClosure(node.body);\n    return function () {\n      var data = objectClosure();\n\n      var currentScope = _this21.getCurrentScope();\n\n      var newScope = new Scope(data, currentScope, WithScopeName); // const data = objectClosure();\n      // copy all properties\n      // for (let k in data) {\n      // \tnewScope.data[k] = data[k];\n      // }\n\n      _this21.setCurrentScope(newScope); // save last value\n\n\n      var result = _this21.setValue(bodyClosure());\n\n      _this21.setCurrentScope(currentScope);\n\n      return result;\n    };\n  };\n\n  _proto2.throwStatementHandler = function throwStatementHandler(node) {\n    var _this22 = this;\n\n    var argumentClosure = this.createClosure(node.argument);\n    return function () {\n      _this22.setValue(undefined);\n\n      throw argumentClosure();\n    };\n  } // try{...}catch(e){...}finally{}\n  ;\n\n  _proto2.tryStatementHandler = function tryStatementHandler(node) {\n    var _this23 = this;\n\n    var blockClosure = this.createClosure(node.block);\n    var handlerClosure = node.handler ? this.catchClauseHandler(node.handler) : null;\n    var finalizerClosure = node.finalizer ? this.createClosure(node.finalizer) : null;\n    return function () {\n      var currentScope = _this23.getCurrentScope();\n\n      var currentContext = _this23.getCurrentContext();\n\n      var labelStack = currentScope.labelStack.concat([]);\n\n      var callStack = _this23.callStack.concat([]);\n\n      var result = EmptyStatementReturn;\n      var finalReturn;\n      var throwError;\n\n      var reset = function reset() {\n        _this23.setCurrentScope(currentScope); //reset scope\n\n\n        _this23.setCurrentContext(currentContext); //reset context\n\n\n        currentScope.labelStack = labelStack; //reset label stack\n\n        _this23.callStack = callStack; //reset call stack\n      };\n      /**\r\n       * try{...}catch(e){...}finally{...} execution sequence:\r\n       * try stmt\r\n       * try throw\r\n       * catch stmt (if)\r\n       * finally stmt\r\n       *\r\n       * finally throw or finally return\r\n       * catch throw or catch return\r\n       * try return\r\n       */\n\n\n      try {\n        result = _this23.setValue(blockClosure());\n\n        if (result instanceof Return) {\n          finalReturn = result;\n        }\n      } catch (err) {\n        reset();\n\n        if (_this23.isInterruptThrow(err)) {\n          throw err;\n        }\n\n        if (handlerClosure) {\n          try {\n            result = _this23.setValue(handlerClosure(err));\n\n            if (result instanceof Return) {\n              finalReturn = result;\n            }\n          } catch (err) {\n            reset();\n\n            if (_this23.isInterruptThrow(err)) {\n              throw err;\n            } // save catch throw error\n\n\n            throwError = err;\n          }\n        }\n      } // finally {\n\n\n      if (finalizerClosure) {\n        try {\n          //do not save finally result\n          result = finalizerClosure();\n\n          if (result instanceof Return) {\n            finalReturn = result;\n          } // finalReturn = finalizerClosure();\n\n        } catch (err) {\n          reset();\n\n          if (_this23.isInterruptThrow(err)) {\n            throw err;\n          } // save finally throw error\n\n\n          throwError = err;\n        } // if (finalReturn instanceof Return) {\n        // \tresult = finalReturn;\n        // }\n\n      } // }\n\n\n      if (throwError) throw throwError;\n\n      if (finalReturn) {\n        return finalReturn;\n      }\n\n      return result;\n    };\n  } // ... catch(e){...}\n  ;\n\n  _proto2.catchClauseHandler = function catchClauseHandler(node) {\n    var _this24 = this;\n\n    var paramNameGetter = this.createParamNameGetter(node.param);\n    var bodyClosure = this.createClosure(node.body);\n    return function (e) {\n      var result;\n\n      var currentScope = _this24.getCurrentScope();\n\n      var scopeData = currentScope.data; // get param name \"e\"\n\n      var paramName = paramNameGetter();\n      var isInScope = hasOwnProperty.call(scopeData, paramName); //paramName in scopeData;\n      // save \"e\"\n\n      var oldValue = scopeData[paramName]; // add \"e\" to scope\n\n      scopeData[paramName] = e; // run\n\n      result = bodyClosure(); // reset \"e\"\n\n      if (isInScope) {\n        scopeData[paramName] = oldValue;\n      } else {\n        //unset\n        delete scopeData[paramName];\n      }\n\n      return result;\n    };\n  };\n\n  _proto2.continueStatementHandler = function continueStatementHandler(node) {\n    return function () {\n      return node.label ? new ContinueLabel(node.label.name) : Continue;\n    };\n  };\n\n  _proto2.breakStatementHandler = function breakStatementHandler(node) {\n    return function () {\n      return node.label ? new BreakLabel(node.label.name) : Break;\n    };\n  };\n\n  _proto2.switchStatementHandler = function switchStatementHandler(node) {\n    var _this25 = this;\n\n    var discriminantClosure = this.createClosure(node.discriminant);\n    var caseClosures = node.cases.map(function (item) {\n      return _this25.switchCaseHandler(item);\n    });\n    return function () {\n      var value = discriminantClosure();\n      var match = false;\n      var result;\n      var ret, defaultCase;\n\n      for (var i = 0; i < caseClosures.length; i++) {\n        var item = caseClosures[i]();\n        var test = item.testClosure();\n\n        if (test === DefaultCase) {\n          defaultCase = item;\n          continue;\n        }\n\n        if (match || test === value) {\n          match = true;\n          ret = _this25.setValue(item.bodyClosure()); // notice: never return Break!\n\n          if (ret === EmptyStatementReturn) continue;\n\n          if (ret === Break) {\n            break;\n          }\n\n          result = ret;\n\n          if (result instanceof Return || result instanceof BreakLabel || result instanceof ContinueLabel || result === Continue) {\n            break;\n          }\n        }\n      }\n\n      if (!match && defaultCase) {\n        ret = _this25.setValue(defaultCase.bodyClosure());\n        var isEBC = ret === EmptyStatementReturn || ret === Break; // notice: never return Break or Continue!\n\n        if (!isEBC) {\n          result = ret;\n        }\n      }\n\n      return result;\n    };\n  };\n\n  _proto2.switchCaseHandler = function switchCaseHandler(node) {\n    var testClosure = node.test ? this.createClosure(node.test) : function () {\n      return DefaultCase;\n    };\n    var bodyClosure = this.createClosure({\n      type: \"BlockStatement\",\n      body: node.consequent\n    });\n    return function () {\n      return {\n        testClosure: testClosure,\n        bodyClosure: bodyClosure\n      };\n    };\n  } // label: xxx\n  ;\n\n  _proto2.labeledStatementHandler = function labeledStatementHandler(node) {\n    var _this26 = this;\n\n    var labelName = node.label.name;\n    var bodyClosure = this.createClosure(node.body);\n    return function () {\n      var result;\n\n      var currentScope = _this26.getCurrentScope();\n\n      currentScope.labelStack.push(labelName);\n      result = bodyClosure(node); // stop break label\n\n      if (result instanceof BreakLabel && result.value === labelName) {\n        result = EmptyStatementReturn;\n      }\n\n      currentScope.labelStack.pop();\n      return result;\n    };\n  };\n\n  _proto2.debuggerStatementHandler = function debuggerStatementHandler(node) {\n    return function () {\n      debugger;\n      return EmptyStatementReturn;\n    };\n  } // get es3/5 param name\n  ;\n\n  _proto2.createParamNameGetter = function createParamNameGetter(node) {\n    if (node.type === \"Identifier\") {\n      return function () {\n        return node.name;\n      };\n    } else {\n      throw this.createInternalThrowError(_messages.Messages.ParamTypeSyntaxError, node.type, node);\n    }\n  };\n\n  _proto2.createObjectKeyGetter = function createObjectKeyGetter(node) {\n    var getter; // var obj = { title: \"\" }\n\n    if (node.type === \"Identifier\") {\n      getter = function getter() {\n        return node.name;\n      };\n    } else {\n      // Literal or ...\n      // var obj = { \"title\": \"\" } or others...\n      getter = this.createClosure(node);\n    }\n\n    return function () {\n      return getter();\n    };\n  };\n\n  _proto2.createMemberKeyGetter = function createMemberKeyGetter(node) {\n    // s['a'];  node.computed = true\n    // s.foo;  node.computed = false\n    return node.computed ? this.createClosure(node.property) : this.createObjectKeyGetter(node.property);\n  } // for UnaryExpression UpdateExpression AssignmentExpression\n  ;\n\n  _proto2.createObjectGetter = function createObjectGetter(node) {\n    var _this27 = this;\n\n    switch (node.type) {\n      case \"Identifier\":\n        return function () {\n          return _this27.getScopeDataFromName(node.name, _this27.getCurrentScope());\n        };\n\n      case \"MemberExpression\":\n        return this.createClosure(node.object);\n\n      default:\n        throw this.createInternalThrowError(_messages.Messages.AssignmentTypeSyntaxError, node.type, node);\n    }\n  } // for UnaryExpression UpdateExpression AssignmentExpression\n  ;\n\n  _proto2.createNameGetter = function createNameGetter(node) {\n    switch (node.type) {\n      case \"Identifier\":\n        return function () {\n          return node.name;\n        };\n\n      case \"MemberExpression\":\n        return this.createMemberKeyGetter(node);\n\n      default:\n        throw this.createInternalThrowError(_messages.Messages.AssignmentTypeSyntaxError, node.type, node);\n    }\n  };\n\n  _proto2.varDeclaration = function varDeclaration(name) {\n    var context = this.collectDeclVars;\n    context[name] = undefined;\n  };\n\n  _proto2.funcDeclaration = function funcDeclaration(name, func) {\n    var context = this.collectDeclFuncs;\n    context[name] = func;\n  };\n\n  _proto2.addDeclarationsToScope = function addDeclarationsToScope(declVars, declFuncs, scope) {\n    var scopeData = scope.data;\n\n    for (var key in declFuncs) {\n      var value = declFuncs[key];\n      scopeData[key] = value ? value() : value;\n    }\n\n    for (var _key5 in declVars) {\n      if (!(_key5 in scopeData)) {\n        scopeData[_key5] = void 0;\n      }\n    }\n  };\n\n  _proto2.getScopeValue = function getScopeValue(name, startScope) {\n    var scope = this.getScopeFromName(name, startScope);\n    return scope.data[name];\n  };\n\n  _proto2.getScopeDataFromName = function getScopeDataFromName(name, startScope) {\n    return this.getScopeFromName(name, startScope).data;\n  };\n\n  _proto2.getScopeFromName = function getScopeFromName(name, startScope) {\n    var scope = startScope;\n\n    do {\n      if (name in scope.data) {\n        //if (hasOwnProperty.call(scope.data, name)) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return this.globalScope;\n  };\n\n  _proto2.setValue = function setValue(value) {\n    var isFunctionCall = this.callStack.length;\n\n    if (this.isVarDeclMode || isFunctionCall || value === EmptyStatementReturn || value === Break || value === Continue || value instanceof BreakLabel || value instanceof ContinueLabel) {\n      return value;\n    }\n\n    this.value = value instanceof Return ? value.value : value;\n    return value;\n  };\n\n  _proto2.getValue = function getValue() {\n    return this.value;\n  };\n\n  return Interpreter;\n}();\n\nexports.Interpreter = Interpreter;\nInterpreter.version = version;\nInterpreter.eval = internalEval;\nInterpreter.Function = internalFunction;\nInterpreter.ecmaVersion = 5; // alert.call(globalContextInFunction, 1);\n// fix: alert.call({}, 1); // Illegal invocation\n// function func(){\n//     this;// Interpreter.globalContextInFunction\n// }\n// func()\n\nInterpreter.globalContextInFunction = void 0;\nInterpreter.global = Object.create(null);","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Messages = exports.InterruptThrowReferenceError = exports.InterruptThrowSyntaxError = exports.InterruptThrowError = exports.ThrowTypeError = exports.ThrowReferenceError = exports.ThrowSyntaxError = exports.ThrowError = void 0;\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar ThrowError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inheritsLoose(ThrowError, _Error);\n\n  function ThrowError() {\n    return _Error.apply(this, arguments) || this;\n  }\n\n  return ThrowError;\n}(_wrapNativeSuper(Error));\n\nexports.ThrowError = ThrowError;\n\nvar ThrowSyntaxError =\n/*#__PURE__*/\nfunction (_SyntaxError) {\n  _inheritsLoose(ThrowSyntaxError, _SyntaxError);\n\n  function ThrowSyntaxError() {\n    return _SyntaxError.apply(this, arguments) || this;\n  }\n\n  return ThrowSyntaxError;\n}(_wrapNativeSuper(SyntaxError));\n\nexports.ThrowSyntaxError = ThrowSyntaxError;\n\nvar ThrowReferenceError =\n/*#__PURE__*/\nfunction (_ReferenceError) {\n  _inheritsLoose(ThrowReferenceError, _ReferenceError);\n\n  function ThrowReferenceError() {\n    return _ReferenceError.apply(this, arguments) || this;\n  }\n\n  return ThrowReferenceError;\n}(_wrapNativeSuper(ReferenceError));\n\nexports.ThrowReferenceError = ThrowReferenceError;\n\nvar ThrowTypeError =\n/*#__PURE__*/\nfunction (_TypeError) {\n  _inheritsLoose(ThrowTypeError, _TypeError);\n\n  function ThrowTypeError() {\n    return _TypeError.apply(this, arguments) || this;\n  }\n\n  return ThrowTypeError;\n}(_wrapNativeSuper(TypeError));\n\nexports.ThrowTypeError = ThrowTypeError;\n\nvar InterruptThrowError =\n/*#__PURE__*/\nfunction (_ThrowError) {\n  _inheritsLoose(InterruptThrowError, _ThrowError);\n\n  function InterruptThrowError() {\n    return _ThrowError.apply(this, arguments) || this;\n  }\n\n  return InterruptThrowError;\n}(ThrowError);\n\nexports.InterruptThrowError = InterruptThrowError;\n\nvar InterruptThrowSyntaxError =\n/*#__PURE__*/\nfunction (_ThrowSyntaxError) {\n  _inheritsLoose(InterruptThrowSyntaxError, _ThrowSyntaxError);\n\n  function InterruptThrowSyntaxError() {\n    return _ThrowSyntaxError.apply(this, arguments) || this;\n  }\n\n  return InterruptThrowSyntaxError;\n}(ThrowSyntaxError);\n\nexports.InterruptThrowSyntaxError = InterruptThrowSyntaxError;\n\nvar InterruptThrowReferenceError =\n/*#__PURE__*/\nfunction (_ThrowReferenceError) {\n  _inheritsLoose(InterruptThrowReferenceError, _ThrowReferenceError);\n\n  function InterruptThrowReferenceError() {\n    return _ThrowReferenceError.apply(this, arguments) || this;\n  }\n\n  return InterruptThrowReferenceError;\n}(ThrowReferenceError);\n\nexports.InterruptThrowReferenceError = InterruptThrowReferenceError;\nvar Messages = {\n  UnknownError: [3001, \"%0\", InterruptThrowError],\n  ExecutionTimeOutError: [3002, \"Script execution timed out after %0ms\", InterruptThrowError],\n  NodeTypeSyntaxError: [1001, \"Unknown node type: %0\", InterruptThrowReferenceError],\n  BinaryOperatorSyntaxError: [1002, \"Unknown binary operator: %0\", InterruptThrowReferenceError],\n  LogicalOperatorSyntaxError: [1003, \"Unknown logical operator: %0\", InterruptThrowReferenceError],\n  UnaryOperatorSyntaxError: [1004, \"Unknown unary operator: %0\", InterruptThrowReferenceError],\n  UpdateOperatorSyntaxError: [1005, \"Unknown update operator: %0\", InterruptThrowReferenceError],\n  ObjectStructureSyntaxError: [1006, \"Unknown object structure: %0\", InterruptThrowReferenceError],\n  AssignmentExpressionSyntaxError: [1007, \"Unknown assignment expression: %0\", InterruptThrowReferenceError],\n  VariableTypeSyntaxError: [1008, \"Unknown variable type: %0\", InterruptThrowReferenceError],\n  ParamTypeSyntaxError: [1009, \"Unknown param type: %0\", InterruptThrowReferenceError],\n  AssignmentTypeSyntaxError: [1010, \"Unknown assignment type: %0\", InterruptThrowReferenceError],\n  FunctionUndefinedReferenceError: [2001, \"%0 is not a function\", ThrowReferenceError],\n  VariableUndefinedReferenceError: [2002, \"%0 is not defined\", ThrowReferenceError],\n  IsNotConstructor: [2003, \"%0 is not a constructor\", ThrowTypeError]\n};\nexports.Messages = Messages;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createContext = createContext;\nexports.compileFunction = compileFunction;\nexports.runInContext = _runInContext;\nexports.Script = exports.runInNewContext = void 0;\n\nvar _main = require(\"./interpreter/main\");\n\n// TODO:\n// add tests\nfunction createContext(ctx) {\n  if (ctx === void 0) {\n    ctx = Object.create(null);\n  }\n\n  return ctx;\n}\n\nfunction compileFunction(code, params, options) {\n  if (params === void 0) {\n    params = [];\n  }\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var ctx = options.parsingContext;\n  var timeout = options.timeout === undefined ? 0 : options.timeout;\n  var wrapCode = \"\\n    (function anonymous(\" + params.join(\",\") + \"){\\n         \" + code + \"\\n    });\\n    \";\n  var interpreter = new _main.Interpreter(ctx, {\n    ecmaVersion: options.ecmaVersion,\n    timeout: timeout,\n    rootContext: options.rootContext,\n    globalContextInFunction: options.globalContextInFunction\n  });\n  return interpreter.evaluate(wrapCode);\n}\n\nfunction _runInContext(code, ctx, options) {\n  var interpreter = new _main.Interpreter(ctx, options);\n  return interpreter.evaluate(code);\n}\n\nvar runInNewContext = _runInContext;\nexports.runInNewContext = runInNewContext;\n\nvar Script =\n/*#__PURE__*/\nfunction () {\n  function Script(code) {\n    this._code = code;\n  }\n\n  var _proto = Script.prototype;\n\n  _proto.runInContext = function runInContext(ctx) {\n    return _runInContext(this._code, ctx);\n  };\n\n  _proto.runInNewContext = function runInNewContext(ctx) {\n    return _runInContext(this._code, ctx);\n  };\n\n  return Script;\n}();\n\nexports.Script = Script;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _vm = require(\"./vm\");\n\nvar _default = function _default(code, ctx, options) {\n  return (0, _vm.runInContext)(code, ctx, options);\n};\n\nexports.default = _default;","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _vm = require(\"./vm\");\n\nfunction _default() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  var code = args.pop();\n  return (0, _vm.compileFunction)(code || \"\", args);\n}"]}